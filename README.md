# CMC-term-4-tests
That prac again

------------------------------------------------------------------------------------------------------
intPairTask:
------------------------------------------------------------------------------------------------------

Опишите абстрактный класс IntPair, представлящий пару целых чисел и имеющий чисто виртуальную функцию
  
<code>virtual int Measure() const;</code>  
  
Унаследуйте от IntPair класс intRectangle, задающий понятие прямоугольника с целочисленными сторонами.
Функцию Measure() определите как площадь прямоугольника. Введите в класс операцию сложения, которая по
двум прямоугольникам, имеющим хотя бы одну общую сторону, строит новый прямоугольник, образованный 
"склеиванием" двух исходных. В случае, если совпадают обе стороны, производите "склеивание" по длинной
стороне. В результирующем объекте первым числом должна быть длина совпавшей стороны исходных прямоугольников,
вторым числом - сумма остальных сторон. Если совпадающих сторон не найдено, выбрасывайте исключение класса
badAdditionб в объекте которого должны содержаться длины сторон прямоугольников, сложение которых не 
удалось.

В результате следующая функция main () :  
  
<pre>
int main() { 
    try{ 
        intRectangle a(3, 5), b(5, 7), c(11, 4), d(6, 11);
        intRectangle p, q;
        p = a + b;
        q = c + d;
        printf("%d\n", (p+q).measure());
        printf("%d\n", (q+a).measure());
    }  <br>
    catch(const badAddition & bad){
        printf("Bad addition: (%d*%d) + (%d*%d)\n",
            bad.getX1(), bad.getY1(), bad.getX2(), bad.getY2());
    }
    return 0;
}
</pre>

должна откомпилироваться без ошибок, предупреждений, отработать и выдать :  
  
160  <br>
Bad addition: (11х10)+(3х5)  
  
<strong>Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только
функции-члены класса, использование директивы friend запрещено. Для инициализации объектов используются
конструкторы. Никакие методы не должны изменять внутренние поля объектов, допускаются только функции,
возвращающие значения полей, но не меняющие их.</strong>


floatPairTask:  
------------------------------------------------------------------------------------------------------
  
Опишите абстрактный класс FloatPair, представлящий пару float чисел и имеющий
чисто виртуальную функцию
  
<code>virtual int Measure() const;</code>
    
для вычисления некоторой (неизвестной на момент создания класса) меры.
    
Унаследуйте от FloatPair класс Segment, задающий понятие отрезка числовой прямой.
При попытке сконструировать отрезок, начальная точка которого правее конечной,
выбрасывайте исключение типа badSegment. Функцию Меasure() определите как длину
отрезка.
  
Введите в классе операцию сложения, которая по двум отрезкам, полностью или
частично перекрывающимся, строит новый отрезок, содержащий все точки исходных
отрезков (объединение). Если отрезки не имеют общих точек, их объединение
не будет отрезком; в этом случае выбрасывайте исключение класса BadAddition, в
объекте которого должны содержаться границы обоих отрезков, которые не удалось
сложить.
  
В результате следующая функция main():  

<pre>
int main()
{
    try{
        segment f(1, 2), g(0.5, 5), h(2.5, 6.5);
        printf("%3.3f, %3.3f, %3.3f\n",
            (f+g).measure(), (g+h).measure(), (f+g+h).measure());
        printf("%3.3f\n", (f+h).measure());
    }
    catch(const badAddition & bad){
        printf("Bad addition: [%3.3f; %3.3f] + [%3.3f; %3.3f]\n",
            bad.getA1(), bad.getB1(), bad.getA2(), bad.getB2());
    }
    catch(badSegment b){
        printf("Bad segment\n");
    }
    return 0;
}
</pre>

должна откомпилироваться без ошибок и предупреждений, отработать и выдать  
  
4.500, 6.000, 6.000  <br>
BadAddition: [1.000; 2.000]+[2.500; 6.500]  
  
<strong> Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными 
могут быть только функции-члены класса, использование директивы friend запрещено. Для
инициализации объектов используются конструкторы. Никакие методы не должны изменять
внутренние поля объектов, допускаются только функции, возвращающие значения полей, но не
меняющие их. </strong>


Lexer
------------------------------------------------------------------------------------------------------

<strong>В обеих задачах программа должна быть оформлена так, чтобы при наличии аргументов командной строки анализу в качествве цепочки подвергался первый из аргументов, а при отсутствии аргументов - поток стандартного ввода до возникновения ситуации "конец файла".</strong>
По итогам работы программа должна напечатать YES или NO.

Дана регулярная грамматика:
<pre>
S -> B* | A@
A -> C< | A< | A= | A-
B -> C> | B> | B= | B-
C -> C= | C- | -
</pre>
(здесь S, A, B, C - нетерминальные символы, -, =, <, >, *, " - терминальные и обозначают сами себя)

Определите, какой язык порождает эа грамматика.
Напишите анализатор для этой грамматики в виде конечного автомата. Автомат должен быть инкапсулирован в объект класса, имеющего в публичной части только конструктор, деструктор (если таковой нужен) и 2 метода: один для передачи автомату очередного символа, второй для проверки, допустима ли цепочка (второй метод вызывается, когда цепочка закончилась). Все остальные методы, а также необходимое для работы автомата должно быть скрыто в приватной части класса. <strong>Не используйте исключения в этой задаче!</strong> Введите в автомат ошибочное состояние, если это нужно.

Syntaxer
------------------------------------------------------------------------------------------------------

Дана грамматика:
<pre>
S -> (R
R -> *S) | (N)
N -> aN | (RN | e
</pre>
Символы S, R, N - нетермиинальные, символы ()* обозначают сами себя, а - все остальные символы типа char, кроме трех перечисленных, е - пустая последовательность.

Определите, какой язык порождает эта грамматика.
Напишите анализатор методом рекурсивного спуска. Анализатор должен быть инкапсулирован в объект класса, имеющего в публичной части только конструктор, деструктор и метод для запуска анализатора. Все остальные методы, а также все необходимое для работы анализатора должно быть скрыто в приватной части класса. В случае ошибки выбрасывайте исключение. Для чтения символов опишите абстрактный класс с одним чисто виртуальным методом int GetChar(), от него унаследуйте два класса: первый реализует GetChar() как чтение символа из стандартного потока ввода, второй получает в качестве параметра конструктора некую строку, а метод реализует путем выдачи очередного символа из этой строки. Адрес соответствующего объекта передавайте анализатору через параметр его конструктора.
